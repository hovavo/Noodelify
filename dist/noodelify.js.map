{"version":3,"sources":["Noodle.js","NoodlePoint.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"noodelify.js","sourcesContent":["class Noodle extends Group {\n  // TODO: Width getter (/setter?)\n  // TODO: More directions?\n\n\n  constructor(source = new Group(), path, isHorizontal = false, resolution = 5) {\n    super();\n\n    this.isHorizontal = isHorizontal;\n    this.resolution = resolution;\n    this.source = source;\n    this.path = path;\n  }\n\n  set source(source) {\n    if (this._source) {\n      this._source.remove();\n      delete this._source;\n    }\n\n    this._source = source;\n    if (this._source.clipped) {\n      this._source._clipItem.remove();\n      this._source.clipped = false;\n    }\n\n    // Flat list of child path items\n    this._sourcePaths = [];\n\n    // If source item is a path, add it\n    if (this._source.segments) {\n      this._source.flatten();\n      this._sourcePaths.push(this._source);\n    }\n\n    // Add all child paths\n    for (let path of this._source.getItems({class: 'Path'})) {\n      path.flatten();\n      this._sourcePaths.push(path);\n    }\n\n    // Default path\n    this.path = this.isHorizontal ?\n      new Path([this._source.bounds.leftCenter, this._source.bounds.rightCenter]) :\n      new Path([this._source.bounds.topCenter, this._source.bounds.bottomCenter]);\n\n    // Default stretch\n    this._stretchStart = 0;\n    this._stretchEnd = 0;\n\n    // Create Noodle points\n    this.processSourcePoints();\n\n    this.addChild(source);\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  set path(path) {\n    if (!path) return;\n\n    if (this._path) this._path.remove();\n\n    this._path = path;\n    this._path.selected = this.selected;\n    this.addChild(path);\n\n    this.update();\n  }\n\n  get path() {\n    return this._path;\n  }\n\n  set stretchStart(val) {\n    this._stretchStart = val;\n    if (this.source)\n      this.processSourcePoints();\n  }\n\n  get stretchStart() {\n    return this._stretchStart;\n  }\n\n  set stretchEnd(val) {\n    this._stretchEnd = val;\n    if (this.source)\n      this.processSourcePoints();\n  }\n\n  get stretchEnd() {\n    return this._stretchEnd;\n  }\n\n  get stretchLength() {\n    return this.path.length - this.stretchEnd - this.stretchStart;\n  }\n\n  get shrinked() {\n    return (this.path.length - this.stretchEnd) < this.stretchStart;\n  }\n\n  update() {\n    if (!this._sourcePaths) return;\n    this._sourcePaths.forEach(path => {\n      // Create new set of points based on original offsets and distances\n      if (!path._noodlePoints) return;\n\n      path.removeSegments();\n\n      path._noodlePoints.forEach((noodlePoint, i) => {\n        let newPoint = noodlePoint.toPoint(this);\n        // Interpolate more points where needed\n        if (path.lastSegment) {\n          let prevNoodlePoint = path._noodlePoints[i - 1];\n          let dist = noodlePoint.getDistance(prevNoodlePoint, this);\n          if (dist > this.resolution) {\n            let numSteps = dist / this.resolution;\n            for (let i = 1; i < numSteps; i++) {\n              let offset = i / numSteps;\n              let newSubNoodlePoint = NoodlePoint.interpolate(prevNoodlePoint, noodlePoint, offset, this)\n              let newSubPoint = newSubNoodlePoint.toPoint(this);\n              path.add(newSubPoint);\n            }\n          }\n        }\n\n        path.add(newPoint);\n      });\n    });\n  }\n\n  processSourcePoints() {\n    for (let path of this._sourcePaths) {\n      // map to noodle points\n      path._noodlePoints = path.segments.map(segment => {\n        return NoodlePoint.fromPoint(segment.point, this);\n      });\n\n      // fix for closed paths\n      if (path.closed)\n        path._noodlePoints.push(path._noodlePoints[0].clone());\n    }\n  }\n\n  loadSVG(url, onLoad) {\n    let _this = this;\n    project.importSVG(url, {\n      expandShapes: true,\n      onLoad: function (group) {\n        _this.source = group;\n        if (onLoad)\n          onLoad(_this);\n      }\n    });\n  }\n}\n\npaper.Noodle = Noodle;","class NoodlePoint {\n\n  constructor(locationNormalized, offset, locationSticky, locationStretch, stickySide) {\n    this.offset = offset;\n    this.locationNormalized = locationNormalized;\n    this.locationSticky = locationSticky;\n    this.locationStretch = locationStretch;\n    this.stickySide = stickySide;\n  }\n\n  static fromPoint(point, noodle) {\n    let location;\n    let boundsThickness;\n    let offset;\n\n    if (!noodle.isHorizontal) {\n      location = point.y - noodle.source.bounds.top;\n      boundsThickness = noodle.source.bounds.width;\n      offset = point.x - noodle.source.bounds.left - boundsThickness / 2;\n    }\n    else {\n      location = point.x - noodle.source.bounds.left;\n      boundsThickness = noodle.source.bounds.height;\n      offset = point.y - noodle.source.bounds.top - boundsThickness / 2\n    }\n\n    return NoodlePoint.fromPathLocation(location, offset, noodle);\n  }\n\n  static fromPathLocation(location, offset, noodle) {\n    let locationSticky;\n    let stickySide;\n    let locationStretch;\n\n    if (location < noodle.stretchStart) {\n      locationSticky = location;\n      stickySide = 1;\n    }\n\n    else if (location > noodle.path.length - noodle.stretchEnd) {\n      locationSticky = noodle.path.length - location;\n      stickySide = -1;\n    }\n\n    locationStretch = (location - noodle.stretchStart) / noodle.stretchLength;\n\n    return new NoodlePoint(\n      location / noodle.path.length,\n      offset,\n      locationSticky,\n      locationStretch,\n      stickySide\n    );\n  }\n\n  toPoint(noodle) {\n    let path = noodle.path;\n    let loc = this.toPathLocation(noodle);\n    let pathPoint = path.getPointAt(loc);\n    let normal = path.getNormalAt(loc) * this.offset;\n    return pathPoint + normal;\n  }\n\n  toPathLocation(noodle) {\n    let path = noodle.path;\n\n    if (noodle.shrinked) {\n      return path.length * this.locationNormalized;\n    }\n\n    if (this.sticky) {\n      if (this.stickyStart) {\n        return this.locationSticky;\n      }\n      else if (this.stickyEnd) {\n        return path.length - this.locationSticky;\n      }\n    }\n    return noodle.stretchStart + noodle.stretchLength * this.locationStretch;\n  }\n\n  clone() {\n    return new NoodlePoint(\n      this.locationNormalized,\n      this.offset,\n      this.locationSticky,\n      this.locationStretch,\n      this.stickySide\n    );\n  }\n\n  getDistance(otherNoodlePoint, noodle) {\n    return Math.abs(this.toPathLocation(noodle) - otherNoodlePoint.toPathLocation(noodle));\n  }\n\n  get sticky() {\n    return !isNaN(this.locationSticky);\n  }\n\n  get stickyStart() {\n    return this.stickySide == 1;\n  }\n\n  get stickyEnd() {\n    return this.stickySide == -1;\n  }\n\n  static interpolate(point1, point2, time, noodle) {\n    let startLocation = point1.toPathLocation(noodle);\n    let endLocation = point2.toPathLocation(noodle);\n    let locationDiff = endLocation - startLocation;\n    let offsetDiff = point2.offset - point1.offset;\n    return NoodlePoint.fromPathLocation(\n      startLocation + locationDiff * time,\n      point1.offset + offsetDiff * time,\n      noodle\n    );\n  }\n}\n\npaper.NoodlePoint = NoodlePoint;"]}