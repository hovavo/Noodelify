{"version":3,"sources":["Noodle.js","NoodlePoint.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"noodelify.js","sourcesContent":["class Noodle extends Group {\n  // TODO V2: Stretch\n\n  constructor(source = new Group(), path, isHorizontal = false, resolution = 5) {\n    super();\n    this.isHorizontal = isHorizontal;\n    this.resolution = resolution;\n    this.source = source;\n    this.path = path;\n  }\n\n  set source(source) {\n    if (this._source) {\n      this._source.remove();\n      delete this._source;\n    }\n\n    this._source = source;\n    if (this._source.clipped) {\n      this._source._clipItem.remove();\n      this._source.clipped = false;\n    }\n\n    // Flat list of child path items\n    this._sourcePaths = [];\n\n    // If source item is a path, add it\n    if (this._source.segments)\n      this._sourcePaths.push(this._source);\n\n    // Add all child paths\n    for (let path of this._source.getItems({class: 'Path'}))\n      this._sourcePaths.push(path);\n\n\n    // Create Noodle points\n    for (let path of this._sourcePaths) {\n\n      // subdivide curves:\n      for (let i = path.curves.length - 1; i >= 0; i--) {\n        let curve = path.curves[i];\n        if (!curve.isStraight()) {\n          let n = Math.floor(curve.length);\n          for (let i = n; i > 0; i--) {\n            curve.divideAt(i);\n          }\n        }\n      }\n\n      // map to noodle points\n      path._sourcePoints = path.segments.map(segment => {\n        return NoodlePoint.fromPoint(segment.point, this._source.bounds, this.isHorizontal);\n      });\n\n      // fix for closed paths\n      if (path.closed)\n        path._sourcePoints.push(path._sourcePoints[0].clone());\n    }\n\n    this.addChild(source);\n    this.path = this.isHorizontal ?\n      new Path([this._source.bounds.leftCenter, this._source.bounds.rightCenter]) :\n      new Path([this._source.bounds.topCenter, this._source.bounds.bottomCenter]);\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  set path(path) {\n    if (!path) return;\n\n    if (this._path) this._path.remove();\n\n    this._path = path;\n    this.addChild(path);\n\n\n    this._sourcePaths.forEach(path => {\n      // Create new set of points based on original offsets and distances\n      let outputPoints = [];\n      path._sourcePoints.forEach((noodlePoint, i) => {\n        let newPoint = noodlePoint.toPoint(this._path);\n        // Interpolate more points where needed\n        let prevPoint = outputPoints[outputPoints.length - 1];\n        if (prevPoint) {\n          let prevNoodlePoint = path._sourcePoints[i - 1];\n          let dist = noodlePoint.getDistance(prevNoodlePoint) * this._path.length;\n          if (dist > this.resolution) {\n            let numSteps = dist / this.resolution;\n            for (let i = 1; i < numSteps; i++) {\n              let offset = i / numSteps;\n              let newSubPoint =\n                NoodlePoint.interpolate(prevNoodlePoint, noodlePoint, offset)\n                  .toPoint(this._path);\n\n              outputPoints.push(newSubPoint);\n            }\n          }\n        }\n        outputPoints.push(newPoint);\n      });\n\n      // Override source segments\n      path.segments = outputPoints;\n    });\n  }\n\n  get path() {\n    return this._path;\n  }\n\n  update() {\n    this.path = this.path;\n    this.path.selected = this.selected;\n  }\n\n  loadSVG(url, onLoad) {\n    let _this = this;\n    project.importSVG(url, {\n      expandShapes: true,\n      onLoad: function (group) {\n        _this.source = group;\n        if (onLoad)\n          onLoad(_this);\n      }\n    });\n  }\n}\n\npaper.Noodle = Noodle;","class NoodlePoint {\n  constructor(offset, distance) {\n    this.offset = offset;\n    this.distance = distance;\n  }\n\n  static fromPoint(point, bounds, isHorizontal = false) {\n    if (!isHorizontal) {\n      return new NoodlePoint(\n        (point.y - bounds.top) / bounds.height,\n        point.x - bounds.left - bounds.width / 2\n      );\n    }\n    else {\n      return new NoodlePoint(\n        (point.x - bounds.left) / bounds.width,\n        point.y - bounds.top - bounds.height / 2\n      );\n    }\n  }\n\n  toPoint(path) {\n    let pathPoint = path.getPointAt(path.length * this.offset);\n    let normal = path.getNormalAt(path.length * this.offset) * this.distance;\n    return pathPoint + normal;\n  }\n\n  clone() {\n    return new NoodlePoint(this.offset, this.distance);\n  }\n\n  getDistance(otherNoodlePoint) {\n    return Math.abs(this.offset - otherNoodlePoint.offset);\n  }\n\n  static interpolate(point1, point2, offset) {\n    let offsetDiff = point2.offset - point1.offset;\n    let distanceDiff = point2.distance - point1.distance;\n    return new NoodlePoint(\n      point1.offset + offsetDiff * offset,\n      point1.distance + distanceDiff * offset\n    );\n  }\n}\n\npaper.NoodlePoint = NoodlePoint;"]}